"""Image processing and object detection utilities.

This module provides tools for:
1. Downloading images from Telegram messages
2. Running YOLOv8 object detection
3. Storing detection results in Oracle
"""
from __future__ import annotations

import os
from pathlib import Path
from typing import List, Dict, Optional

import torch
from PIL import Image
from ultralytics import YOLO

from src.constants import env
from src.db import get_connection
from src.utils.file_io import ensure_parent


class ImageProcessor:
    """Handles image downloading, processing, and detection."""
    
    def __init__(self, model_name: str = "yolov8n.pt"):
        """Initialize YOLO model and set up directories.
        
        Args:
            model_name: Name of the YOLO model to load (default: yolov8n.pt)
        """
        self.model = YOLO(model_name)
        self.images_dir = Path(env.ORACLE_USER) / "images"
        ensure_parent(self.images_dir)
    
    def download_image(self, message: Dict[str, Any]) -> Optional[Path]:
        """Download an image from a Telegram message if it exists.
        
        Args:
            message: Telegram message dictionary containing photo info
            
        Returns:
            Path to downloaded image or None if no image
        """
        if "photo" not in message:
            return None
            
        # Get the largest photo size
        photo = max(message["photo"], key=lambda p: p.get("size", 0))
        file_id = photo["file_id"]
        
        # TODO: Implement actual download logic using Telethon
        # This is a placeholder - you'll need to implement the download
        # using your Telethon client
        
        return None  # Placeholder
    
    def detect_objects(self, image_path: Path) -> List[Dict[str, Any]]:
        """Run YOLO detection on an image.
        
        Args:
            image_path: Path to image file
            
        Returns:
            List of detection results with class, confidence, etc.
        """
        results = self.model(image_path)
        detections = []
        
        for r in results:
            boxes = r.boxes
            for box in boxes:
                detections.append({
                    "class": box.cls.item(),
                    "confidence": box.conf.item(),
                    "bbox": box.xyxy[0].tolist()
                })
        
        return detections
    
    def store_detections(self, message_id: int, detections: List[Dict[str, Any]]) -> None:
        """Store detection results in Oracle.
        
        Args:
            message_id: Foreign key to TELEGRAM_RAW.MESSAGES
            detections: List of detection results
        """
        with get_connection() as conn:
            cur = conn.cursor()
            
            # Create table if not exists
            cur.execute("""
                BEGIN
                    EXECUTE IMMEDIATE 'CREATE TABLE telegram_raw.image_detections (
                        message_id      NUMBER REFERENCES telegram_raw.messages(message_id),
                        detection_id    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        class_id        NUMBER,
                        confidence      NUMBER(5,4),
                        bbox_x1         NUMBER,
                        bbox_y1         NUMBER,
                        bbox_x2         NUMBER,
                        bbox_y2         NUMBER,
                        created_at      TIMESTAMP DEFAULT SYSTIMESTAMP
                    )';
                EXCEPTION WHEN OTHERS THEN
                    IF SQLCODE != -955 THEN RAISE; END IF;
                END;
            """)
            
            # Insert detections
            for det in detections:
                cur.execute("""
                    INSERT INTO telegram_raw.image_detections (
                        message_id, class_id, confidence, 
                        bbox_x1, bbox_y1, bbox_x2, bbox_y2
                    ) VALUES (
                        :1, :2, :3, :4, :5, :6, :7
                    )
                """, [
                    message_id,
                    det["class"],
                    det["confidence"],
                    *det["bbox"]
                ])
            
            conn.commit()


def process_channel_images(channel_slug: str, date: str) -> None:
    """Process all images from a channel on a specific date.
    
    Args:
        channel_slug: Channel identifier
        date: Date in YYYY-MM-DD format
    """
    processor = ImageProcessor()
    
    with get_connection() as conn:
        cur = conn.cursor()
        
        # Get messages with photos
        cur.execute("""
            SELECT message_id, payload
            FROM telegram_raw.messages
            WHERE channel_slug = :1
            AND TRUNC(message_ts) = TO_DATE(:2, 'YYYY-MM-DD')
            AND JSON_EXISTS(payload, '$.photo')
        """, [channel_slug, date])
        
        for message_id, payload in cur:
            message = json.loads(payload)
            image_path = processor.download_image(message)
            
            if image_path:
                detections = processor.detect_objects(image_path)
                processor.store_detections(message_id, detections)
                
                # Clean up downloaded image
                image_path.unlink(missing_ok=True)
